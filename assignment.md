# 주문/결제 백엔드 직무 과제

## 과제 개요
- 구현에 필요한 도구나 라이브러리는 자유롭게 선택해 사용할 수 있습니다.
- AI 도구 역시 제한 없이 활용하셔도 됩니다.
- 요구사항에 명시되지 않았거나 흐름이 불명확한 부분은 임의로 보완하되, 그 근거를 README에 함께 작성해 주세요.
- 이번 과제는 주문/결제 승인 워크플로우를 구현하는 과제입니다.
- 권장 진행 기간: 7일~10일

## 과제 명세서

### 1) 기능 개요
서비스에는 주문 생성과 결제 승인 기능이 있습니다.

주문은 생성되면 결제 대기 상태가 됩니다.  
사용자가 결제 승인을 요청하면 결제 시도가 생성되며, 최종 승인 여부는 즉시 확정되지 않을 수 있습니다.

시스템은 결제 승인 요청을 안정적으로 처리하기 위해 다음을 고려해야 합니다.
- 동일 요청이 여러 번 들어와도 결과가 안정적이어야 합니다(멱등).
- 결제 승인 요청이 몰려도 시스템이 무너지지 않도록 제한이 필요합니다(레이트 리밋).
- 중간 실패가 발생해도 재시도가 가능해야 합니다(재시도 안전성).
- 상태 전이가 규칙을 벗어나지 않게 해야 합니다(상태 전이 검증).

요구사항에 없는 세부 정책(예: 결제 실패 후 주문 상태를 어디까지 바꾸는지, 재결제 허용 여부 등)은 설계자가 정하고, README에 근거를 적어 주세요.

### 2) 기능 요구사항(필수)
아래 기능을 구현해야 합니다.
- 주문 생성
- 주문 단건 조회
- 주문 목록 조회(페이징)
- 결제 승인 요청 생성
- 결제 시도 조회(단건)
- 결제 처리 비동기화(RDBMS 기반 처리, 배치/스케줄러 방식 권장)

추가 기능은 자유입니다. 다만 필수 요구사항을 깨지 않도록 주의해 주세요.

### 3) 기술적 요구사항
- Framework: Spring Boot 3.x
- Language: Java 17 이상(원하시면 21도 가능)
- Build Tool: Gradle
- Database: H2(in-memory) 또는 PostgreSQL 중 택1
  - 선택 근거를 README에 작성해 주세요.
- ORM/SQL: JPA 또는 MyBatis 중 택1
- Architecture: Layered Architecture(Controller/Service/Repository)
- 메시지 브로커는 사용하지 않습니다(Kafka, RabbitMQ 등 금지).
- 비동기 처리는 RDBMS와 배치 또는 스케줄러 기반으로 구현해 주세요.
- API 문서화는 필수입니다(Swagger/OpenAPI 권장).

### 4) 도메인 가이드(강제 아님)
아래는 설계를 돕기 위한 가이드입니다. 그대로 따라도 되고, 다른 모델을 사용해도 됩니다.
- Order(주문)
  - 주문은 금액(amount), 고객(customerId) 같은 정보를 가진다.
  - 주문은 상태를 가진다.
- PaymentAttempt(결제 시도)
  - 결제 승인 요청이 들어오면 생성된다.
  - 멱등키를 저장할 수 있어야 한다.
  - 처리 결과(성공/실패/오류 등)를 저장할 수 있어야 한다.

상태 값과 전이 규칙은 자유롭게 정하되, 논리적으로 일관되어야 합니다.

### 5) 비기능 요구사항(중요)

#### 5-1) 멱등 처리
- 결제 승인 요청 API는 Idempotency-Key를 입력으로 받는 것을 권장합니다(헤더 또는 바디).
- 같은 키로 동일한 요청이 반복되면, 중복 생성/중복 승인 없이 동일한 결과가 반환되어야 합니다.
- 같은 키인데 요청 파라미터가 달라지는 경우(예: amount 변경)는 어떻게 처리할지 정책을 정하고 문서화해 주세요.

#### 5-2) 레이트 리밋
- 결제 승인 요청 API는 트래픽 제한이 있어야 합니다.
- 제한 기준(주문 단위, 사용자 단위, IP 단위 등)은 자유롭게 선택해도 됩니다.
- 정책과 구현 근거를 README에 작성해 주세요.
- 제한 초과 시 429를 반환하는 것을 권장합니다.

#### 5-3) 재시도 안전성
- 네트워크 재시도, 클라이언트 중복 호출, 배치 재처리 상황에서 데이터가 깨지지 않아야 합니다.
- 중복 처리 방지 방법(유니크 제약, 락, 버전 컬럼 등)은 자유롭게 선택해 주세요.
- 동시 요청 시나리오를 최소 1개 이상 고려해 주세요.

#### 5-4) 결제 처리 비동기화
- 결제 승인은 요청 즉시 확정이 아니어도 됩니다.
- 메시지 브로커 없이 RDBMS에 결제 처리 대상 데이터를 저장하고, 배치/스케줄러가 처리하는 방식으로 구현해 주세요.
- 처리 주기, 처리 단위, 중복 처리 방지 전략은 설계자가 결정하고 근거를 문서화해 주세요.

### 6) 필수 구현 API 목록
요구사항은 최소 범위만 제공합니다. 상세 스펙은 설계자가 보완해도 됩니다.

#### 6-1) 주문 생성
- POST /api/orders
- 주문을 생성합니다.
- 응답에는 주문 식별자와 상태 정보가 포함되어야 합니다.

#### 6-2) 주문 단건 조회
- GET /api/orders/{orderId}
- 주문의 현재 상태를 확인할 수 있어야 합니다.

#### 6-3) 주문 목록 조회
- GET /api/orders?page=0&size=20&sort=createdAt,desc
- 페이징 가능한 결과를 반환해야 합니다.
- 정렬 기준은 하나 이상 지원해야 합니다(예: createdAt).

#### 6-4) 결제 승인 요청
- POST /api/orders/{orderId}/payments/approve
- 결제 승인을 요청합니다.
- 멱등키를 통해 중복 요청을 제어해야 합니다.
- 요청 즉시 결제 성공 여부가 확정되지 않아도 됩니다.
- 결제 승인 요청이 수락되면, 결제 시도 식별자를 응답으로 내려 주세요.

#### 6-5) 결제 시도 단건 조회
- GET /api/payments/{paymentAttemptId}
- 결제 시도의 상태(처리 전/처리 중/성공/실패)를 조회할 수 있어야 합니다.

### 7) 선택 구현(가산점)
아래 기능은 선택입니다. 구현 여부와 정책은 설계자가 결정하고, README에 근거를 적어 주세요.

기본 선택 기능
- 주문 취소
- 결제 취소
- 결제 환불

운영/조회 선택 기능
- 주문/결제 검색 필터 추가(상태, 기간, 금액 범위)
- 결제 시도 목록 조회(주문별 결제 이력 페이징)
- 관리자용 조회 API(전체 주문/결제 조회, 실패 건만 보기)
- 재처리 버튼 API(FAILED/ERROR 건 수동 재시도 트리거)

아키텍처/신뢰성 선택 기능
- 아웃박스 패턴 적용(비동기 이벤트 발행 또는 후처리 내구성 강화 목적)
- 서킷 브레이커 적용(외부 의존성 또는 가짜 PG 호출을 외부 서비스로 분리한 경우에 한해 권장)
- 슬로우 스타터 적용(애플리케이션 기동 직후 트래픽 급증 완화, 워밍업 전략)

### 8) 제출 방식
- GitHub에 private 레포지토리를 생성합니다.
- 브랜치 전략은 자유지만, PR 기반 개발을 권장합니다.
- README에는 아래를 꼭 포함해 주세요.
  - 실행 방법
  - 설계한 정책과 근거(상태 전이, 멱등, 레이트 리밋, 비동기 처리)
  - 선택 기술 스택과 이유(DB, ORM 등)
  - 간단한 시나리오 기반 테스트 방법(수동 테스트 절차도 가능)

### 9) (참고) 평가 기준
- 기능 요구사항: 40%
- 비기능 요구사항: 40%
- 코드 품질/테스트: 5%
- 문서화: 15%

## 참고
- 위 요구사항은 최소 조건만 제공합니다.
- 정답은 하나가 아니며, 설계 선택의 이유를 명확히 설명하는 것이 중요합니다.
